@page "/"
@using Share.Model
@using Share.Util
@inject ChatClient ChatClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IMessageService IMessageService
@inject IJSRuntime JS

<PageTitle>Chat</PageTitle>

<MudContainer Id="chatContainer" Class="pa-4 my-4" Style="height: 400px; overflow: auto;">
    @foreach (var message in _messageList)
    {
        <MudChat ChatPosition=@GetChatBubblePosition(message.Sender)>
            <MudChatHeader Name=@message.Sender Time=@message.Timestamp.TimeOfDay.ToString()/>
            <MudChatBubble>
                @message.Content
            </MudChatBubble>
        </MudChat>
    }
</MudContainer>

<AuthorizeView>
    <Authorized>
        <MudTextField T="string" Label="Outlined" Variant="Variant.Outlined" @bind-value="_messageInput" Lines="3" />
        <MudButton 
            Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.Send" Color="Color.Primary"
            OnClick="Send" Disabled="@(!ChatClient.IsConnected())">Send</MudButton>
    </Authorized>
    <NotAuthorized>
        You must be logged in to send a message
        <LogIn/>
    </NotAuthorized>
</AuthorizeView>

<script>
    async function GoToLast(id) {
        console.log("called" + id)
        if (!id) return;
        const container = document.getElementById(id);
        if (container) {
            container.scroll({
                top: 10000000,
                behavior: "smooth",
            });
        }
    }
</script>

@code {
    private List<Message> _messageList = [];
    private string? _messageInput;
    private string? _currentUser;

    protected override async Task OnInitializedAsync()
    {
        _messageList = IMessageService.GetMessages();
        ChatClient.OnMessageReceived += HandleMessageReceived;
        await ChatClient.StartConnection();
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            _currentUser = user.FindFirst(c => c.Type == "name")?.Value;
        }
    }

    protected override async void OnAfterRender(bool firstRender)
    {
        await JS.InvokeVoidAsync("GoToLast", "chatContainer");
    }

    private void HandleMessageReceived(Message message)
    {
        _messageList.Add(message);
        InvokeAsync(StateHasChanged);
    }

    private async Task Send()
    {
        try
        {
            var sanitizedInput = InputSanitizer.Clean(_messageInput);
            var message = MessageFactory.Create(_currentUser ?? "Unknown User", sanitizedInput);
            IMessageService.AddMessage(message);
            await ChatClient.SendMessage(message);
        }
        catch (ArgumentException e)
        {
            ChatClient.Log(e);
        }
        finally
        {
            _messageInput = "";
        }
    }

    private ChatBubblePosition GetChatBubblePosition(string sender)
    {
        if (_currentUser != null && _currentUser == sender)
        {
            return ChatBubblePosition.End;
        }
        return ChatBubblePosition.Start;
    }
    
}
